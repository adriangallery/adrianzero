<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdrianSHOP - Traits Store</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'VT323', monospace;
            background: #808080;
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 4.5rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 .adrian {
            color: #333333;
        }

        .header h1 .shop {
            color: #00ff00;
        }

        .header .subtitle {
            font-size: 1.45rem;
            color: white;
            margin-bottom: 20px;
            font-family: 'VT323', monospace;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.3rem;
            opacity: 0.9;
        }

        .connect-section {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .connect-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            font-family: 'VT323', monospace;
        }

        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .account-section {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .wallet-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .wallet-address {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 10px;
            font-family: monospace;
            font-weight: bold;
        }

        .balance-info {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .balance-item {
            background: #e8f5e8;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
        }

        .disconnect-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'VT323', monospace;
        }

        .disconnect-btn:hover {
            background: #c82333;
        }

        .shop-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .section-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-family: 'VT323', monospace;
        }

        .shop-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .shop-stats {
            display: flex;
            gap: 15px;
            align-items: center;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
        }

        .approve-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .approve-btn {
            background: #ffc107;
            color: #212529;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
        }

        .cart-section {
            background: rgba(51, 51, 51, 0.95);
            border: 2px solid #333333;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: white;
            font-family: 'VT323', monospace;
            display: none;
        }

        .cart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .cart-items {
            max-height: 200px;
            overflow-y: auto;
        }

        .cart-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #555;
        }

        .cart-total {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #555;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .cart-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .item-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 3px solid transparent;
            position: relative;
        }

        .item-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .item-card.in-cart {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .item-image {
            width: 100%;
            height: 200px;
            object-fit: contain;
            background: #f8f9fa;
        }

        .item-info {
            padding: 18px 15px 15px 15px;
        }

        .item-name {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
        }

        .item-price {
            color: #00ff00;
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 5px;
            font-family: 'VT323', monospace;
        }

        .item-availability {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 5px;
            font-family: 'VT323', monospace;
        }

        .connectivity-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            text-align: center;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            color: #856404;
            display: none;
        }

        .item-category {
            color: #0066cc;
            font-size: 0.9rem;
            font-family: 'VT323', monospace;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .item-rarity {
            font-size: 0.9rem;
            font-family: 'VT323', monospace;
            margin-bottom: 5px;
        }

        .item-description {
            font-size: 0.8rem;
            color: #555;
            margin-bottom: 8px;
            font-style: italic;
            line-height: 1.2;
        }

        .item-other-attrs {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            font-family: 'VT323', monospace;
        }

        .item-allowlist {
            background: #e8f5e8;
            color: #155724;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-bottom: 8px;
            font-family: 'VT323', monospace;
        }

        .item-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .action-btn {
            flex: 1;
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-family: 'VT323', monospace;
            min-width: 80px;
        }

        .action-btn:hover {
            transform: translateY(-1px);
        }

        .action-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .action-btn.free {
            background: #28a745;
        }

        .action-btn.remove {
            background: #dc3545;
        }

        .action-btn.quick {
            background: #28a745;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error, .success, .info {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-family: 'VT323', monospace;
            display: none;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .no-items {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
            font-family: 'VT323', monospace;
            display: none;
        }

        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 30px;
        }

        .page-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'VT323', monospace;
        }

        .page-btn.active {
            background: #667eea;
        }

        .page-btn:disabled {
            background: #adb5bd;
            cursor: not-allowed;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            color: white;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 3.5rem;
            }
            
            .items-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 15px;
            }
            
            .shop-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .wallet-info {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><span class="adrian">Adrian</span><span class="shop">SHOP</span></h1>
            <div class="subtitle">Official Traits Store</div>
            <p>Buy traits and assets with $ADRIAN tokens</p>
        </div>

        <!-- Connect Section -->
        <div id="connect-section" class="connect-section">
            <h2>Connect Your Wallet</h2>
            <p style="margin: 20px 0;">Connect your MetaMask wallet to browse and purchase items</p>
            <button id="connectBtn" class="connect-btn">Connect Wallet</button>
        </div>

        <!-- Account Section -->
        <div id="account-section" class="account-section">
            <div class="wallet-info">
                <div>
                    <strong>Connected Wallet:</strong>
                    <span id="walletAddress" class="wallet-address">Not connected</span>
                </div>
                <div class="balance-info">
                    <div class="balance-item">
                        <strong>ADRIAN:</strong> <span id="adrianBalance">0</span>
                    </div>
                    <div class="balance-item">
                        <strong>ETH:</strong> <span id="ethBalance">0</span>
                    </div>
                </div>
                <button id="disconnectBtn" class="disconnect-btn">Disconnect</button>
            </div>
        </div>

        <!-- Approval Section -->
        <div id="approve-section" class="approve-section">
            <h3>Approve ADRIAN Tokens</h3>
            <p>You need to approve ADRIAN tokens before making purchases</p>
            <button id="approveBtn" class="approve-btn">Approve ADRIAN</button>
            <div id="approve-status" style="margin-top: 10px;"></div>
        </div>

        <!-- Cart Section -->
        <div id="cart-section" class="cart-section">
            <div class="cart-header">
                <h3>üõí Shopping Cart</h3>
                <button id="clearCartBtn" class="action-btn remove">Clear Cart</button>
            </div>
            <div id="cart-items" class="cart-items"></div>
            <div id="cart-total" class="cart-total"></div>
            <div class="cart-actions">
                <button id="checkoutBtn" class="action-btn" style="flex: 2;">Checkout</button>
                <button id="approveForCartBtn" class="action-btn" style="background: #ffc107; color: #212529;">Approve Tokens</button>
            </div>
        </div>

        <!-- Shop Section -->
        <div id="shop-section" class="shop-section" style="display: none;">
            <h2 class="section-title">Traits Store</h2>
            
            <div class="shop-controls">
                <div class="shop-stats">
                    <span>Items: <span id="totalItems">0</span></span>
                    <span>|</span>
                    <span>Page: <span id="currentPage">1</span></span>
                </div>
            </div>

            <div id="loading" class="loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading items...</p>
            </div>

            <div id="error" class="error"></div>
            <div id="success" class="success"></div>
            <div id="info" class="info"></div>

            <div id="no-items" class="no-items">
                <p>No items available in the shop</p>
            </div>

            <div id="items-grid" class="items-grid"></div>

            <div id="pagination" class="pagination"></div>
        </div>

        <div class="footer">
            Powered by $ADRIAN
        </div>
    </div>

    <script>
        // Configuration
        const ALCHEMY_API_KEY = "5qIXA1UZxOAzi8b9l0nrYmsQBO9-W7Ot";
        const BASE_NETWORK = {
            chainId: "0x2105", // 8453 in hex
            chainName: "Base Mainnet",
            nativeCurrency: {
                name: "ETH",
                symbol: "ETH",
                decimals: 18,
            },
            rpcUrls: [`https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`],
            blockExplorerUrls: ["https://basescan.org/"],
        };

        // Contract addresses
        const ADRIAN_SHOP_CONTRACT = "0x4B265927b1521995Ce416BBa3BEd98231d2E946b";
        const ADRIAN_TOKEN_CONTRACT = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";

        // Contract ABIs
        const SHOP_ABI = [
            "function getActiveItems(uint256 offset, uint256 limit) view returns (tuple(uint256 assetId, uint256 price, uint256 quantityAvailable, uint256 sold, uint256 startTime, uint256 endTime, bool active, uint256 maxPerWallet, bool canPurchase, string purchaseError, bool hasAllowlist, uint256 freePerWallet, uint256 freeUsedByUser, uint256 freeRemaining, bool isAllowlisted)[] items, uint256 totalActive)",
            "function getShopItemView(uint256 assetId, address user) view returns (tuple(uint256 assetId, uint256 price, uint256 quantityAvailable, uint256 sold, uint256 startTime, uint256 endTime, bool active, uint256 maxPerWallet, bool canPurchase, string purchaseError, bool hasAllowlist, uint256 freePerWallet, uint256 freeUsedByUser, uint256 freeRemaining, bool isAllowlisted))",
            "function purchaseItem(uint256 assetId, uint256 quantity, bool useFree) external",
            "function batchPurchase(tuple(uint256 assetId, uint256 quantity, bool useFree)[] requests) external",
            "function claimFreeItem(uint256 assetId, uint256 quantity) external"
        ];

        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)"
        ];

        // App state
        var currentAccount = null;
        var currentPage = 1;
        var itemsPerPage = 12;
        var allItems = [];
        var cart = [];
        var adrianBalance = 0;
        var ethBalance = 0;
        var approvedAmount = 0;

        // DOM Elements
        var connectSection = document.getElementById('connect-section');
        var accountSection = document.getElementById('account-section');
        var shopSection = document.getElementById('shop-section');
        var approveSection = document.getElementById('approve-section');
        var cartSection = document.getElementById('cart-section');
        var connectBtn = document.getElementById('connectBtn');
        var disconnectBtn = document.getElementById('disconnectBtn');
        var walletAddress = document.getElementById('walletAddress');
        var adrianBalanceEl = document.getElementById('adrianBalance');
        var ethBalanceEl = document.getElementById('ethBalance');
        var loading = document.getElementById('loading');
        var error = document.getElementById('error');
        var success = document.getElementById('success');
        var info = document.getElementById('info');
        var noItems = document.getElementById('no-items');
        var itemsGrid = document.getElementById('items-grid');
        var totalItemsEl = document.getElementById('totalItems');
        var currentPageEl = document.getElementById('currentPage');
        var pagination = document.getElementById('pagination');
        var cartItemsEl = document.getElementById('cart-items');
        var cartTotalEl = document.getElementById('cart-total');
        var clearCartBtn = document.getElementById('clearCartBtn');
        var checkoutBtn = document.getElementById('checkoutBtn');
        var approveBtn = document.getElementById('approveBtn');
        var approveForCartBtn = document.getElementById('approveForCartBtn');

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, ethers available:', typeof ethers !== 'undefined');
            
            connectBtn.addEventListener('click', connectWallet);
            disconnectBtn.addEventListener('click', disconnectWallet);
            clearCartBtn.addEventListener('click', clearCart);
            checkoutBtn.addEventListener('click', checkout);
            approveBtn.addEventListener('click', approveTokens);
            approveForCartBtn.addEventListener('click', approveTokensForCart);
            
            // Check if wallet is already connected
            checkConnection();
        });

        // Check if wallet is connected
        async function checkConnection() {
            if (window.ethereum) {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        await connectWallet();
                    }
                } catch (err) {
                    console.error("Failed to check connection:", err);
                }
            }
        }

        // Connect wallet
        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    showError("MetaMask not detected! Please install MetaMask to use this application.");
                    return;
                }
                
                if (typeof ethers === 'undefined') {
                    showError("Ethers library not loaded. Please refresh the page.");
                    return;
                }
                
                // Request account access
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                currentAccount = accounts[0];
                
                // Check if user is on the Base network
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== BASE_NETWORK.chainId) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: BASE_NETWORK.chainId }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [BASE_NETWORK],
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }
                
                // Update UI
                connectSection.style.display = "none";
                accountSection.style.display = "block";
                shopSection.style.display = "block";
                walletAddress.textContent = currentAccount.slice(0,6) + '...' + currentAccount.slice(-4);
                
                // Load balances and shop data
                await loadBalances();
                await loadShopItems();
                
                // Event listeners for account/chain changes
                window.ethereum.on('accountsChanged', function(accounts) {
                    window.location.reload();
                });
                
                window.ethereum.on('chainChanged', function() {
                    window.location.reload();
                });
                
                showSuccess("Wallet connected successfully!");
                
            } catch (err) {
                console.error("Connection error:", err);
                showError(err.message || "Error connecting wallet");
            }
        }

        // Disconnect wallet
        function disconnectWallet() {
            currentAccount = null;
            currentPage = 1;
            allItems = [];
            cart = [];
            
            connectSection.style.display = "block";
            accountSection.style.display = "none";
            shopSection.style.display = "none";
            approveSection.style.display = "none";
            cartSection.style.display = "none";
            
            itemsGrid.innerHTML = "";
            walletAddress.textContent = "Not connected";
            updateCartDisplay();
            hideMessages();
        }

        // Load user balances with retry logic
        async function loadBalances() {
            try {
                console.log('Loading balances...');
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                
                // Add delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Get ETH balance with retry
                const ethBalanceWei = await retryCall(() => provider.getBalance(currentAccount));
                ethBalance = parseFloat(ethers.utils.formatEther(ethBalanceWei));
                ethBalanceEl.textContent = ethBalance.toFixed(4);
                
                // Add delay between calls
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Get ADRIAN balance and allowance with retry
                const adrianContract = new ethers.Contract(ADRIAN_TOKEN_CONTRACT, ERC20_ABI, provider);
                
                const adrianBalanceWei = await retryCall(() => adrianContract.balanceOf(currentAccount));
                adrianBalance = parseFloat(ethers.utils.formatEther(adrianBalanceWei));
                adrianBalanceEl.textContent = adrianBalance.toLocaleString();
                
                // Add delay before allowance call
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Check approval amount
                const allowanceWei = await retryCall(() => adrianContract.allowance(currentAccount, ADRIAN_SHOP_CONTRACT));
                approvedAmount = parseFloat(ethers.utils.formatEther(allowanceWei));
                
                console.log('Balances loaded - ETH:', ethBalance, 'ADRIAN:', adrianBalance, 'Approved:', approvedAmount);
                
            } catch (err) {
                console.error("Error loading balances:", err);
                
                // Handle rate limiting specifically
                if (err.message && err.message.includes('rate limit')) {
                    showError("‚è≥ Rate limited. Please wait a moment and try again.");
                } else {
                    showError("Error loading wallet balances. Please refresh and try again.");
                }
            }
        }

        // Retry function for blockchain calls
        async function retryCall(fn, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (err) {
                    console.log(`Attempt ${i + 1}/${maxRetries} failed:`, err.message);
                    
                    if (i === maxRetries - 1) {
                        throw err; // Re-throw on last attempt
                    }
                    
                    // Wait before retrying, with exponential backoff
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }

        // Load shop items from contract with retry logic
        async function loadShopItems() {
            showLoading();
            hideMessages();
            
            try {
                console.log('Loading items from contract...');
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const shopContract = new ethers.Contract(ADRIAN_SHOP_CONTRACT, SHOP_ABI, provider);
                
                // Add delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Get all active items with retry
                const result = await retryCall(() => shopContract.getActiveItems(0, 100));
                const items = result.items;
                const totalActive = result.totalActive.toNumber();
                
                console.log(`Loaded ${items.length} items out of ${totalActive} total active`);
                
                // Process items
                allItems = [];
                for (var i = 0; i < items.length; i++) {
                    var processedItem = processShopItem(items[i]);
                    allItems.push(processedItem);
                    
                    // Add small delay between processing items to avoid overload
                    if (i < items.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                console.log("Processed items:", allItems);
                
                // Load metadata for all items (with error handling)
                try {
                    await loadMetadataForItems();
                } catch (metadataErr) {
                    console.warn('Some metadata failed to load:', metadataErr);
                    showInfo('Items loaded, some details may be incomplete due to CORS restrictions');
                }
                
                displayItems();
                
            } catch (err) {
                console.error("Error loading shop items:", err);
                
                // Handle rate limiting and other specific errors
                if (err.message && err.message.includes('rate limit')) {
                    showError("‚è≥ Rate limited. Please wait a moment and refresh the page.");
                } else if (err.code === 'CALL_EXCEPTION') {
                    showError("Unable to connect to shop contract. Please check your connection and try again.");
                } else {
                    showError("Error loading shop items. Please refresh the page and try again.");
                }
            } finally {
                hideLoading();
            }
        }

        // Load metadata for all items with better error handling
        async function loadMetadataForItems() {
            console.log('Loading metadata for', allItems.length, 'items...');
            
            var metadataPromises = allItems.map(function(item, index) {
                // Add staggered delay to avoid overwhelming the server
                return new Promise(function(resolve) {
                    setTimeout(function() {
                        loadItemMetadata(item).then(resolve).catch(resolve);
                    }, index * 200); // 200ms delay between each request
                });
            });
            
            try {
                await Promise.all(metadataPromises);
                console.log('All metadata loading attempts completed');
            } catch (err) {
                console.error('Error in metadata loading:', err);
            }
        }

        // Load metadata for a single item with CORS handling
        async function loadItemMetadata(item) {
            try {
                console.log('Loading metadata for item', item.assetId);
                
                // Try to load metadata with CORS handling
                var response = await fetch(item.metadataUrl, {
                    mode: 'cors',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    console.warn('Failed to load metadata for item', item.assetId, '- status:', response.status);
                    return;
                }
                
                var metadata = await response.json();
                console.log('Metadata loaded for item', item.assetId, ':', metadata);
                
                // Update item with metadata
                if (metadata.name) {
                    item.name = metadata.name;
                }
                if (metadata.description) {
                    item.description = metadata.description;
                }
                if (metadata.image) {
                    item.imageUrl = metadata.image;
                }
                if (metadata.attributes) {
                    item.attributes = metadata.attributes;
                }
                
            } catch (err) {
                console.warn('Error loading metadata for item', item.assetId, ':', err);
                
                // For CORS errors, try alternative approach or use fallback
                if (err.message && err.message.includes('CORS')) {
                    console.log('CORS error detected, using fallback metadata for item', item.assetId);
                    // Keep the default name and image
                    item.description = 'Official AdrianLAB trait item';
                }
            }
        }

        // Process shop item from contract
        function processShopItem(item) {
            const assetId = item.assetId.toNumber();
            const price = parseFloat(ethers.utils.formatEther(item.price));
            const quantityAvailable = item.quantityAvailable.toNumber();
            const sold = item.sold.toNumber();
            const maxPerWallet = item.maxPerWallet.toNumber();
            const freePerWallet = item.freePerWallet.toNumber();
            const freeUsedByUser = item.freeUsedByUser.toNumber();
            const freeRemaining = item.freeRemaining.toNumber();
            
            // Fix: For cart functionality, always allow adding to cart if item is available
            // Only validate approve for quick buy, not for cart
            let canAddToCart = item.canPurchase;
            let canQuickBuy = item.canPurchase && (price === 0 || approvedAmount >= price);
            let purchaseError = item.purchaseError;
            
            // Override for cart functionality - allow adding to cart even without approve
            if (!canAddToCart && purchaseError === "Insufficient balance") {
                // Check if user actually has enough ADRIAN tokens for cart
                if (adrianBalance >= price) {
                    canAddToCart = true; // Allow adding to cart
                    // Keep canQuickBuy false if no approve
                }
            }
            
            return {
                assetId: assetId,
                name: 'Trait #' + assetId, // Will be updated with metadata
                price: price,
                quantityAvailable: quantityAvailable,
                sold: sold,
                maxPerWallet: maxPerWallet,
                canPurchase: item.canPurchase, // Original contract validation
                canAddToCart: canAddToCart, // Allow adding to cart even without approve
                canQuickBuy: canQuickBuy, // Only allow quick buy if approved
                purchaseError: purchaseError,
                hasAllowlist: item.hasAllowlist,
                freePerWallet: freePerWallet,
                freeUsedByUser: freeUsedByUser,
                freeRemaining: freeRemaining,
                isAllowlisted: item.isAllowlisted,
                imageUrl: 'https://adrianlab.vercel.app/api/render/floppy/' + assetId + '.png',
                metadataUrl: 'https://adrianlab.vercel.app/api/metadata/floppy/' + assetId + '.json',
                description: '',
                attributes: []
            };
        }

        // Display items
        function displayItems() {
            // Calculate pagination
            const totalPages = Math.ceil(allItems.length / itemsPerPage);
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageItems = allItems.slice(startIndex, endIndex);
            
            // Update stats
            totalItemsEl.textContent = allItems.length;
            currentPageEl.textContent = currentPage;
            
            // Display items
            itemsGrid.innerHTML = '';
            
            if (allItems.length === 0) {
                noItems.style.display = 'block';
                itemsGrid.style.display = 'none';
                pagination.style.display = 'none';
                return;
            }
            
            noItems.style.display = 'none';
            itemsGrid.style.display = 'grid';
            
            pageItems.forEach(function(item) {
                var itemCard = document.createElement('div');
                itemCard.className = 'item-card';
                
                // Check if item is in cart
                var inCart = false;
                for (var j = 0; j < cart.length; j++) {
                    if (cart[j].assetId === item.assetId) {
                        inCart = true;
                        break;
                    }
                }
                if (inCart) {
                    itemCard.classList.add('in-cart');
                }
                
                // Add small indicator if metadata failed to load
                var metadataIndicator = '';
                if (item.name.startsWith('Trait #')) {
                    metadataIndicator = '<div style="font-size: 0.7rem; color: #999; margin-bottom: 5px;">‚ö†Ô∏è Limited info due to CORS</div>';
                }
                
                // Create category and rarity display from attributes
                var categoryInfo = '';
                var rarityInfo = '';
                var otherAttributes = [];
                
                if (item.attributes && item.attributes.length > 0) {
                    for (var k = 0; k < item.attributes.length; k++) {
                        var attr = item.attributes[k];
                        if (attr.trait_type && attr.value) {
                            if (attr.trait_type.toLowerCase() === 'category') {
                                categoryInfo = '<div class="item-category">üìÇ ' + attr.value + '</div>';
                            } else if (attr.trait_type.toLowerCase() === 'rarity') {
                                var rarityColor = '#666';
                                if (attr.value.toLowerCase() === 'common') rarityColor = '#999';
                                else if (attr.value.toLowerCase() === 'rare') rarityColor = '#0066cc';
                                else if (attr.value.toLowerCase() === 'epic') rarityColor = '#9933cc';
                                else if (attr.value.toLowerCase() === 'legendary') rarityColor = '#ff6600';
                                
                                rarityInfo = '<div class="item-rarity" style="color: ' + rarityColor + '; font-weight: bold;">üíé ' + attr.value + '</div>';
                            } else if (attr.trait_type !== 'TOTAL MINTED') {
                                // Add other interesting attributes (but skip TOTAL MINTED as it's not user-relevant)
                                otherAttributes.push(attr.trait_type + ': ' + attr.value);
                            }
                        }
                    }
                }
                
                // Limit other attributes to 1-2 most relevant ones
                var otherAttributesDisplay = '';
                if (otherAttributes.length > 0) {
                    otherAttributesDisplay = '<div class="item-other-attrs" style="font-size: 0.8rem; color: #666; margin-bottom: 5px;">';
                    otherAttributesDisplay += otherAttributes.slice(0, 2).join(' ‚Ä¢ ');
                    otherAttributesDisplay += '</div>';
                }
                
                // Create description preview (first 100 characters)
                var descriptionPreview = '';
                if (item.description && item.description.length > 0) {
                    var shortDesc = item.description.length > 80 ? 
                        item.description.substring(0, 80) + '...' : 
                        item.description;
                    descriptionPreview = '<div class="item-description" style="font-size: 0.8rem; color: #555; margin-bottom: 8px; font-style: italic;">' + shortDesc + '</div>';
                }
                
                // Create attributes display
                var attributesInfo = '';
                if (item.attributes && item.attributes.length > 0) {
                    attributesInfo = '<div style="font-size: 0.8rem; color: #666; margin-bottom: 8px;">';
                    for (var k = 0; k < Math.min(item.attributes.length, 3); k++) {
                        var attr = item.attributes[k];
                        if (attr.trait_type && attr.value) {
                            attributesInfo += '<div>' + attr.trait_type + ': ' + attr.value + '</div>';
                        }
                    }
                    attributesInfo += '</div>';
                }
                
                // Create allowlist info
                var allowlistInfo = '';
                if (item.hasAllowlist) {
                    allowlistInfo = '<div class="item-allowlist">' +
                        (item.isAllowlisted ? '‚úÖ Free: ' + item.freeRemaining + '/' + item.freePerWallet : '‚ùå Not Allowlisted') +
                        '</div>';
                }
                
                // Create action buttons with new logic
                var actionButtons = '';
                
                // Always show Add to Cart if item is available (even without approve)
                if (item.canAddToCart) {
                    actionButtons += '<button class="action-btn" onclick="addToCart(' + item.assetId + ', false)">Add to Cart</button>';
                    
                    // Free claim button if available
                    if (item.isAllowlisted && item.freeRemaining > 0) {
                        actionButtons += '<button class="action-btn free" onclick="addToCart(' + item.assetId + ', true)">Claim Free</button>';
                    }
                    
                    // Quick buy only if approved
                    if (item.canQuickBuy) {
                        actionButtons += '<button class="action-btn quick" onclick="quickBuy(' + item.assetId + ')">Quick Buy</button>';
                    }
                } else {
                    // Show error if item is not available at all
                    actionButtons = '<button class="action-btn" disabled>' + item.purchaseError + '</button>';
                }
                
                if (inCart) {
                    actionButtons += '<button class="action-btn remove" onclick="removeFromCart(' + item.assetId + ')">Remove</button>';
                }
                
                itemCard.innerHTML = 
                    '<img src="' + item.imageUrl + '" alt="' + item.name + '" class="item-image" ' +
                         'onerror="this.src=\'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMCAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IiNGNUY1RjUiLz48dGV4dCB4PSIxMDAiIHk9IjEwMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjOTk5OTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+\';">' +
                    '<div class="item-info">' +
                        '<div class="item-name">' + item.name + '</div>' +
                        '<div class="item-price">' + item.price.toLocaleString() + ' $ADRIAN</div>' +
                        metadataIndicator +
                        categoryInfo +
                        rarityInfo +
                        descriptionPreview +
                        otherAttributesDisplay +
                        '<div class="item-availability">' + item.sold + '/' + item.quantityAvailable + ' sold</div>' +
                        allowlistInfo +
                        '<div class="item-actions">' + actionButtons + '</div>' +
                    '</div>';
                
                itemsGrid.appendChild(itemCard);
            });
            
            // Update pagination
            updatePagination(totalPages);
        }

        // Update pagination controls
        function updatePagination(totalPages) {
            pagination.innerHTML = '';
            
            if (totalPages <= 1) {
                pagination.style.display = 'none';
                return;
            }
            
            pagination.style.display = 'flex';
            
            // Previous button
            var prevBtn = document.createElement('button');
            prevBtn.className = 'page-btn';
            prevBtn.textContent = 'Previous';
            prevBtn.disabled = currentPage === 1;
            prevBtn.onclick = function() {
                if (currentPage > 1) {
                    currentPage--;
                    displayItems();
                }
            };
            pagination.appendChild(prevBtn);
            
            // Page numbers
            for (var i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
                    var pageBtn = document.createElement('button');
                    pageBtn.className = 'page-btn';
                    if (i === currentPage) pageBtn.classList.add('active');
                    pageBtn.textContent = i;
                    pageBtn.onclick = (function(pageNum) {
                        return function() {
                            currentPage = pageNum;
                            displayItems();
                        };
                    })(i);
                    pagination.appendChild(pageBtn);
                } else if (i === currentPage - 3 || i === currentPage + 3) {
                    var ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    ellipsis.style.padding = '8px';
                    pagination.appendChild(ellipsis);
                }
            }
            
            // Next button
            var nextBtn = document.createElement('button');
            nextBtn.className = 'page-btn';
            nextBtn.textContent = 'Next';
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.onclick = function() {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayItems();
                }
            };
            pagination.appendChild(nextBtn);
        }

        // Global functions for button clicks
        function addToCart(assetId, useFree) {
            console.log('Adding to cart:', assetId, 'useFree:', useFree);
            
            var item = null;
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].assetId === assetId) {
                    item = allItems[i];
                    break;
                }
            }
            if (!item) return;
            
            // Check if item already in cart
            var existingIndex = -1;
            for (var i = 0; i < cart.length; i++) {
                if (cart[i].assetId === assetId && cart[i].useFree === useFree) {
                    existingIndex = i;
                    break;
                }
            }
            
            if (existingIndex > -1) {
                cart[existingIndex].quantity += 1;
            } else {
                cart.push({
                    assetId: assetId,
                    name: item.name + (useFree ? ' (FREE)' : ''),
                    price: useFree ? 0 : item.price,
                    quantity: 1,
                    useFree: useFree
                });
            }
            
            updateCartDisplay();
            displayItems();
            showInfo('Added ' + item.name + ' to cart');
        }

        function quickBuy(assetId) {
            console.log('Quick buy:', assetId);
            
            var item = null;
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].assetId === assetId) {
                    item = allItems[i];
                    break;
                }
            }
            if (!item) return;
            
            // Quick buy should only be available if canQuickBuy is true
            if (!item.canQuickBuy) {
                if (item.price > approvedAmount) {
                    showError("Please approve ADRIAN tokens first for quick buy");
                    approveSection.style.display = "block";
                } else if (item.price > adrianBalance) {
                    showError("Insufficient ADRIAN balance");
                } else {
                    showError("Quick buy not available for this item");
                }
                return;
            }
            
            purchaseItem(assetId, 1, false);
        }

        function removeFromCart(assetId) {
            console.log('Removing from cart:', assetId);
            
            var newCart = [];
            for (var i = 0; i < cart.length; i++) {
                if (cart[i].assetId !== assetId) {
                    newCart.push(cart[i]);
                }
            }
            cart = newCart;
            
            updateCartDisplay();
            displayItems();
        }

        // Clear cart
        function clearCart() {
            console.log('Clearing cart');
            cart = [];
            updateCartDisplay();
            displayItems();
        }

        // Update cart display
        function updateCartDisplay() {
            if (cart.length === 0) {
                cartSection.style.display = 'none';
                return;
            }
            
            cartSection.style.display = 'block';
            
            // Update cart items
            cartItemsEl.innerHTML = '';
            var totalCost = 0;
            var totalFree = 0;
            
            for (var i = 0; i < cart.length; i++) {
                var item = cart[i];
                var cartItem = document.createElement('div');
                cartItem.className = 'cart-item';
                
                var itemCost = item.useFree ? 0 : item.price * item.quantity;
                totalCost += itemCost;
                
                if (item.useFree) {
                    totalFree += item.quantity;
                }
                
                cartItem.innerHTML =
                    '<span>' + item.name + '</span>' +
                    '<span>' + item.quantity + ' x ' + 
                    (item.useFree ? 'FREE' : item.price.toLocaleString() + ' $ADRIAN') +
                    ' = ' + (item.useFree ? 'FREE' : itemCost.toLocaleString() + ' $ADRIAN') + '</span>';
                
                cartItemsEl.appendChild(cartItem);
            }
            
            // Update total
            cartTotalEl.innerHTML =
                '<div>Total Cost: ' + totalCost.toLocaleString() + ' $ADRIAN</div>' +
                (totalFree > 0 ? '<div>Free Items: ' + totalFree + '</div>' : '') +
                '<div>Your Balance: ' + adrianBalance.toLocaleString() + ' $ADRIAN</div>';
            
            // Update checkout button state - only disable if insufficient balance
            checkoutBtn.disabled = totalCost > adrianBalance;
            
            // Show approval section if needed, but don't disable checkout
            if (totalCost > 0 && totalCost > approvedAmount) {
                approveSection.style.display = "block";
            } else {
                approveSection.style.display = "none";
            }
        }

        // Purchase single item with retry logic
        async function purchaseItem(assetId, quantity, useFree) {
            try {
                showInfo("Preparing purchase transaction...");
                
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const shopContract = new ethers.Contract(ADRIAN_SHOP_CONTRACT, SHOP_ABI, signer);
                
                // Add delay before transaction
                await new Promise(resolve => setTimeout(resolve, 500));
                
                showInfo("Processing purchase...");
                
                const tx = await shopContract.purchaseItem(assetId, quantity, useFree);
                showInfo('Transaction sent: ' + tx.hash);
                
                await tx.wait();
                showSuccess("Purchase completed successfully!");
                
                // Add delay before refreshing data
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Refresh data
                await loadBalances();
                await loadShopItems();
                
            } catch (err) {
                console.error("Purchase error:", err);
                showError(parseBlockchainError(err));
            }
        }

        // Checkout (batch purchase)
        async function checkout() {
            if (cart.length === 0) return;
            
            // Calculate total cost for validation
            var totalCost = 0;
            for (var i = 0; i < cart.length; i++) {
                if (!cart[i].useFree) {
                    totalCost += cart[i].price * cart[i].quantity;
                }
            }
            
            // Check if approval is needed before proceeding
            if (totalCost > 0 && totalCost > approvedAmount) {
                showError("Please approve ADRIAN tokens before checkout");
                approveSection.style.display = "block";
                return;
            }
            
            // Check balance
            if (totalCost > adrianBalance) {
                showError("Insufficient ADRIAN balance for checkout");
                return;
            }
            
            try {
                showInfo("Preparing batch purchase...");
                
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const shopContract = new ethers.Contract(ADRIAN_SHOP_CONTRACT, SHOP_ABI, signer);
                
                // Add delay before transaction
                await new Promise(resolve => setTimeout(resolve, 500));
                
                showInfo("Processing batch purchase...");
                
                // Convert cart to purchase requests
                var requests = cart.map(function(item) {
                    return {
                        assetId: item.assetId,
                        quantity: item.quantity,
                        useFree: item.useFree
                    };
                });
                
                const tx = await shopContract.batchPurchase(requests);
                showInfo('Batch transaction sent: ' + tx.hash);
                
                await tx.wait();
                showSuccess("Batch purchase completed successfully!");
                
                // Add delay before refreshing data
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Clear cart and refresh
                clearCart();
                await loadBalances();
                await loadShopItems();
                
            } catch (err) {
                console.error("Checkout error:", err);
                showError(parseBlockchainError(err));
            }
        }

        // Approve ADRIAN tokens with retry logic
        async function approveTokens() {
            try {
                showInfo("Preparing approval transaction...");
                
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const adrianContract = new ethers.Contract(ADRIAN_TOKEN_CONTRACT, ERC20_ABI, signer);
                
                // Add delay before transaction
                await new Promise(resolve => setTimeout(resolve, 500));
                
                showInfo("Approving ADRIAN tokens...");
                
                // Approve a large amount (equivalent to max uint256)
                const maxAmount = ethers.constants.MaxUint256;
                
                const tx = await adrianContract.approve(ADRIAN_SHOP_CONTRACT, maxAmount);
                showInfo('Approval transaction sent: ' + tx.hash);
                
                await tx.wait();
                showSuccess("ADRIAN tokens approved successfully!");
                
                // Add delay before refreshing balances
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Refresh approval amount and items
                await loadBalances();
                await loadShopItems(); // Refresh items to update button states
                updateCartDisplay();
                
            } catch (err) {
                console.error("Approval error:", err);
                showError(parseBlockchainError(err));
            }
        }

        // Approve tokens for cart
        function approveTokensForCart() {
            approveTokens();
        }

        // UI Helper functions
        function showLoading() {
            loading.style.display = "block";
            itemsGrid.innerHTML = "";
            noItems.style.display = "none";
        }

        function hideLoading() {
            loading.style.display = "none";
        }

        function showError(message) {
            error.textContent = message;
            error.style.display = "block";
            setTimeout(function() {
                error.style.display = "none";
            }, 5000);
        }

        function showSuccess(message) {
            success.textContent = message;
            success.style.display = "block";
            setTimeout(function() {
                success.style.display = "none";
            }, 5000);
        }

        function showInfo(message) {
            info.textContent = message;
            info.style.display = "block";
            setTimeout(function() {
                info.style.display = "none";
            }, 5000);
        }

        function hideMessages() {
            error.style.display = "none";
            success.style.display = "none";
            info.style.display = "none";
        }
    </script>
</body>
</html>