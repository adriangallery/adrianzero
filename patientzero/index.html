<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PatientZERO - Rehabilitation Center</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'VT323', monospace;
            background: #1a1a1a;
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 4.5rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 .patient {
            color: #ff4444;
        }

        .header h1 .zero {
            color: #00ff00;
        }

        .header .subtitle {
            font-size: 1.45rem;
            color: #cccccc;
            margin-bottom: 20px;
            font-family: 'VT323', monospace;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.3rem;
            opacity: 0.9;
            color: #aaaaaa;
        }

        .connect-section {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 1px solid #333;
        }

        .connect-btn {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            font-family: 'VT323', monospace;
        }

        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .account-section {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 1px solid #333;
        }

        .wallet-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .wallet-address {
            background: #2a2a2a;
            padding: 10px 15px;
            border-radius: 10px;
            font-family: monospace;
            font-weight: bold;
            color: #00ff00;
        }

        .disconnect-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'VT323', monospace;
        }

        .disconnect-btn:hover {
            background: #c82333;
        }

        .main-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid #333;
        }

        .section-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #fff;
            text-align: center;
            font-family: 'VT323', monospace;
        }

        .tabs {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .tab-btn {
            background: #333;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-family: 'VT323', monospace;
        }

        .tab-btn.active {
            background: #ff4444;
        }

        .tab-btn:hover {
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .profiles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .profile-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            border: 1px solid #333;
            position: relative;
        }

        .profile-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .profile-image {
            width: 100%;
            height: 200px;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .profile-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .image-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff00;
            font-size: 1.2rem;
        }

        .profile-info {
            padding: 20px;
        }

        .profile-name {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff4444;
        }

        .profile-reward {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #00ff00;
        }

        .profile-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: #cccccc;
        }

        .profile-traits {
            margin-bottom: 15px;
        }

        .traits-title {
            font-size: 1rem;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .traits-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .trait-tag {
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .claim-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            font-weight: bold;
        }

        .claim-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,0,0.3);
        }

        .claim-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .my-adrians-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .adrian-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            border: 1px solid #333;
            cursor: pointer;
        }

        .adrian-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .adrian-card.selected {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .adrian-image {
            width: 100%;
            height: 200px;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .adrian-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .adrian-info {
            padding: 15px;
        }

        .adrian-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        }

        .adrian-id {
            font-size: 1rem;
            color: #cccccc;
            margin-bottom: 5px;
        }

        .adrian-status {
            font-size: 0.9rem;
            color: #888888;
            font-style: italic;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #00ff00;
            font-size: 1.2rem;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #ff4444;
            font-size: 1.2rem;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #cccccc;
            font-size: 1.2rem;
        }

        .status-message {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            font-size: 1.1rem;
        }

        .status-success {
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            border: 1px solid #00ff00;
        }

        .status-error {
            background: rgba(255, 0, 0, 0.1);
            color: #ff4444;
            border: 1px solid #ff4444;
        }

        .status-loading {
            background: rgba(0, 0, 255, 0.1);
            color: #0088ff;
            border: 1px solid #0088ff;
        }

        .no-tokens {
            text-align: center;
            padding: 40px;
            color: #cccccc;
            font-size: 1.2rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-header h3 {
            margin: 0;
            font-size: 1.2rem;
            color: #ff4444;
        }

        .status-badge {
            background-color: #ff4444;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-badge.purchased {
            background-color: #00ff00 !important;
        }
        
        .status-badge.active {
            background-color: #2196F3;
        }
        
        .status-badge.inactive {
            background-color: #FF9800;
        }

        .card-image {
            width: 100%;
            height: 150px;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .card-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .card-content {
            padding: 10px 15px;
        }

        .token-info p {
            margin-bottom: 5px;
            color: #cccccc;
        }

        .card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .action-btn {
            background: #333;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'VT323', monospace;
            font-size: 0.9rem;
        }

        .action-btn:hover {
            background: #444;
        }

        .action-btn.view-btn {
            background: #0088ff;
        }

        .action-btn.view-btn:hover {
            background: #0077cc;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 3rem;
            }
            
            .profiles-grid {
                grid-template-columns: 1fr;
            }
            
            .my-adrians-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }

        /* Menu styles - PatientZERO Theme */
        #menu-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        #menu-container .navbar {
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #ff4444;
            font-family: 'VT323', monospace;
        }

        #menu-container .navbar-nav .nav-link {
            color: #cccccc !important;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        #menu-container .navbar-nav .nav-link:hover {
            color: #ff4444 !important;
            text-shadow: 0 0 10px #ff4444;
        }

        #menu-container .token-symbol {
            color: #00ff00;
            font-weight: bold;
            font-size: 1.4rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        #menu-container .navbar-toggler {
            border-color: #ff4444;
        }

        #menu-container .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba(255, 68, 68, 1)' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }

        /* Adjust first section to account for fixed menu */
        .container {
            padding-top: 60px;
        }

        /* Menu always collapsed - no responsive adjustments needed */
        #menu-container .navbar-nav .nav-link {
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <!-- Include the menu -->
    <div id="menu-container"></div>
    <script>
      // Load the menu
      fetch('../components/menu.html')
        .then(response => response.text())
        .then(html => {
          document.getElementById('menu-container').innerHTML = html;
          const script = document.createElement('script');
          script.src = '../components/menu.js';
          document.head.appendChild(script);
        })
        .catch(error => console.error('Error loading menu:', error));
    </script>

    <div class="container">
        <div class="header">
            <h1><span class="patient">Patient</span><span class="zero">ZERO</span></h1>
            <div class="subtitle">Rehabilitation Center</div>
            <p>Find and recover Adrians matching specific trait profiles</p>
        </div>

        <div class="connect-section" id="connectSection">
            <h2>Connect Your Wallet</h2>
            <p>Connect your wallet to access the rehabilitation center</p>
            <button class="connect-btn" id="connectBtn">Connect Wallet</button>
        </div>

        <div class="account-section" id="accountSection">
            <div class="wallet-info">
                <div>
                    <strong>Connected:</strong>
                    <span class="wallet-address" id="walletAddress"></span>
                </div>
                <button class="disconnect-btn" id="disconnectBtn">Disconnect</button>
            </div>
        </div>

        <div class="main-section" id="mainSection" style="display: none;">
            <div class="tabs">
                <button class="tab-btn active" data-tab="bounties">Active Bounties</button>
                <button class="tab-btn" data-tab="my-adrians">My Adrians</button>
                <button class="tab-btn" data-tab="recovery">Recovery Center</button>
                <button class="tab-btn" data-tab="recovered">RECOVERED FROM REHAB</button>
            </div>

            <div class="tab-content active" id="bounties-tab">
                <div class="section-title">Active Bounty Profiles</div>
                <div id="profilesGrid" class="profiles-grid">
                    <div class="loading">Loading bounty profiles...</div>
                </div>
            </div>

            <div class="tab-content" id="my-adrians-tab">
                <div class="section-title">My Adrians</div>
                <div id="adriansGrid" class="my-adrians-grid">
                    <div class="loading">Loading your AdrianZERO tokens...</div>
                </div>
            </div>

            <div class="tab-content" id="recovery-tab">
                <div class="section-title">Recovery Center</div>
                <div id="recoveryGrid" class="profiles-grid">
                    <div class="loading">Loading recovered profiles...</div>
                </div>
            </div>

            <div class="tab-content" id="recovered-tab">
                <div class="section-title">RECOVERED FROM REHAB</div>
                <div id="recoveredGrid" class="profiles-grid">
                    <div class="loading">Loading recovered tokens...</div>
                </div>
            </div>
        </div>

        <div id="statusMessage" class="status-message" style="display: none;"></div>
    </div>

    <script>
        // Configuration
        const PATIENTZERO_CONTRACT = '0x41BD1D621f9a8dE8f175Dd9814d9c27fAbb9172F';
        const ADRIANZERO_CONTRACT = '0x6e369bf0e4e0c106192d606fb6d85836d684da75';
        const ADRIAN_TOKEN_CONTRACT = '0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea'; // ADRIAN ERC20 token
        const ALCHEMY_API_KEY = '5qIXA1UZxOAzi8b9l0nrYmsQBO9-W7Ot';
        const ALCHEMY_RPC_URL = `https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`;
        const NETWORK = 'base-mainnet';
        
        // Base Network configuration (same as TraitLab)
        const BASE_NETWORK = {
            chainId: "0x2105", // 8453 in hex
            chainName: "Base Mainnet",
            nativeCurrency: {
                name: "ETH",
                symbol: "ETH",
                decimals: 18,
            },
            rpcUrls: [ALCHEMY_RPC_URL],
            blockExplorerUrls: ["https://basescan.org/"],
        };

        // State variables
        let currentAccount = null;
        let patientZeroContract = null;
        let adrianCoreContract = null;
        let myAdrians = [];
        let activeProfiles = [];
        let selectedAdrian = null;

        // DOM elements
        const connectSection = document.getElementById('connectSection');
        const accountSection = document.getElementById('accountSection');
        const mainSection = document.getElementById('mainSection');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const walletAddress = document.getElementById('walletAddress');
        const profilesGrid = document.getElementById('profilesGrid');
        const adriansGrid = document.getElementById('adriansGrid');
        const recoveredGrid = document.getElementById('recoveredGrid');
        const statusMessage = document.getElementById('statusMessage');

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            checkWalletConnection();
        });

        function setupEventListeners() {
            connectBtn.addEventListener('click', connectWallet);
            disconnectBtn.addEventListener('click', disconnectWallet);
            
            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    btn.classList.add('active');
                    const tabId = btn.getAttribute('data-tab') + '-tab';
                    document.getElementById(tabId).classList.add('active');
                    if (tabId === 'recovery-tab') loadRecoveryProfiles();
                    if (tabId === 'recovered-tab') loadRecoveredTokens();
                });
            });
        }

        async function checkWalletConnection() {
            if (typeof window.ethereum !== 'undefined') {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    currentAccount = accounts[0];
                    updateUI();
                    loadData();
                }
            }
        }

        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                showStatus('Please install MetaMask to use this application', 'error');
                return;
            }

            try {
                showStatus('Connecting to wallet...', 'loading');
                
                // Request account access
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                currentAccount = accounts[0];
                
                // Check if user is on the Base network
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== BASE_NETWORK.chainId) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: BASE_NETWORK.chainId }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [BASE_NETWORK],
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }
                
                updateUI();
                loadData();
                showStatus('Wallet connected successfully!', 'success');
            } catch (error) {
                showStatus('Failed to connect wallet: ' + error.message, 'error');
            }
        }

        function disconnectWallet() {
            currentAccount = null;
            updateUI();
            showStatus('Wallet disconnected', 'success');
        }

        function updateUI() {
            if (currentAccount) {
                connectSection.style.display = 'none';
                accountSection.style.display = 'block';
                mainSection.style.display = 'block';
                walletAddress.textContent = currentAccount.slice(0, 6) + '...' + currentAccount.slice(-4);
            } else {
                connectSection.style.display = 'block';
                accountSection.style.display = 'none';
                mainSection.style.display = 'none';
            }
        }

        async function loadData() {
            if (!currentAccount) return;
            
            await Promise.all([
                loadActiveProfiles(),
                loadMyAdrians()
            ]);
        }

        async function loadActiveProfiles() {
            try {
                showStatus('Loading active bounty profiles...', 'loading');
                
                // Load ethers if not available
                if (typeof window.ethers === 'undefined') {
                    await loadEthers();
                }

                // Use Alchemy RPC provider (same as TraitLab)
                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABI(), provider);
                
                // Get active profile IDs
                const activeProfileIds = await contract.getActiveProfiles();
                
                // Get profile details for each active profile
                const profiles = [];
                for (const profileId of activeProfileIds) {
                    const profile = await contract.getProfile(profileId);
                    profiles.push({
                        id: profileId,
                        name: profile.profileName,
                        traitIds: profile.traitIds,
                        reward: profile.reward,
                        active: profile.active,
                        recovered: profile.recovered
                    });
                }
                
                activeProfiles = profiles;
                displayProfiles(profiles);
                showStatus(`Loaded ${profiles.length} active bounty profiles`, 'success');
                
            } catch (error) {
                console.error('Error loading profiles:', error);
                showStatus('Error loading bounty profiles: ' + error.message, 'error');
                profilesGrid.innerHTML = '<div class="error">Failed to load bounty profiles</div>';
            }
        }

        async function loadMyAdrians() {
            try {
                showStatus('Loading your AdrianZERO tokens...', 'loading');
                
                // Load specifically ERC721 tokens from AdrianZERO contract
                const response = await fetch(`https://${NETWORK}.g.alchemy.com/nft/v3/${ALCHEMY_API_KEY}/getNFTsForOwner?owner=${currentAccount}&contractAddresses[]=${ADRIANZERO_CONTRACT}&withMetadata=true&pageSize=50&tokenType=ERC721`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Alchemy API error:', response.status, errorText);
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('AdrianZERO data received:', data);
                console.log('Looking for contract:', ADRIANZERO_CONTRACT);
                console.log('Total NFTs received:', data.ownedNfts ? data.ownedNfts.length : 0);
                
                // Log all contract addresses to see what we're getting
                if (data.ownedNfts) {
                    data.ownedNfts.forEach((nft, index) => {
                        console.log(`NFT ${index}: contract=${nft.contract?.address}, tokenId=${nft.tokenId}, type=${nft.tokenType}`);
                    });
                }
                
                // Process and filter AdrianZERO tokens
                myAdrians = (data.ownedNfts || []).map(nft => {
                    // First, verify this is from the AdrianZERO contract
                    console.log(`Checking NFT: contract=${nft.contract?.address}, expected=${ADRIANZERO_CONTRACT}`);
                    if (nft.contract && nft.contract.address.toLowerCase() !== ADRIANZERO_CONTRACT.toLowerCase()) {
                        console.log(`Skipping token from different contract: ${nft.contract.address}`);
                        return null;
                    }
                    
                    console.log(`Found AdrianZERO token: ${nft.tokenId}`);
                    
                    // Extract tokenId
                    let tokenId;
                    if (nft.tokenId) {
                        tokenId = nft.tokenId;
                    } else if (nft.id && nft.id.tokenId) {
                        tokenId = nft.id.tokenId;
                    } else {
                        console.error("No tokenId found in NFT:", nft);
                        return null;
                    }
                    
                    // Convert tokenId to integer
                    let tokenIdInt;
                    if (typeof tokenId === 'number') {
                        tokenIdInt = tokenId;
                    } else if (tokenId.startsWith('0x')) {
                        tokenIdInt = parseInt(tokenId, 16);
                    } else {
                        tokenIdInt = parseInt(tokenId, 10);
                    }
                    
                    if (isNaN(tokenIdInt)) {
                        console.error("Invalid tokenId format:", tokenId);
                        return null;
                    }
                    
                    // Extract title/name
                    let title = `Adrian #${tokenIdInt}`;
                    if (nft.title) {
                        title = nft.title;
                    } else if (nft.name) {
                        title = nft.name;
                    } else if (nft.metadata && nft.metadata.name) {
                        title = nft.metadata.name;
                    }
                    
                    // Extract image URL with multiple fallbacks
                    let imageUrl = "";
                    
                    // Try multiple locations for image URL (same logic as traitlab)
                    if (nft.raw && nft.raw.metadata && nft.raw.metadata.image) {
                        imageUrl = nft.raw.metadata.image;
                    } else if (nft.media && Array.isArray(nft.media) && nft.media.length > 0) {
                        const mediaSources = ['gateway', 'raw', 'thumbnail', 'format'];
                        for (const source of mediaSources) {
                            if (nft.media[0][source] && typeof nft.media[0][source] === 'string') {
                                imageUrl = nft.media[0][source];
                                break;
                            }
                        }
                    } else if (nft.metadata) {
                        const imageProps = ['image', 'image_url', 'imageUrl', 'imageURI', 'image_uri', 'imageData'];
                        for (const prop of imageProps) {
                            if (nft.metadata[prop] && typeof nft.metadata[prop] === 'string') {
                                imageUrl = nft.metadata[prop];
                                break;
                            }
                        }
                    }
                    
                    // Clean up IPFS URLs
                    if (imageUrl && imageUrl.startsWith('ipfs://')) {
                        imageUrl = imageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
                    }
                    
                    return {
                        tokenId: tokenIdInt,
                        title: title,
                        imageUrl: imageUrl,
                        contract: nft.contract.address,
                        contractName: nft.contract.name || 'AdrianZERO',
                        metadata: nft.metadata || {}
                    };
                }).filter(token => token !== null);
                
                console.log('Processed AdrianZERO tokens:', myAdrians);
                displayMyAdrians(myAdrians);
                showStatus(`Loaded ${myAdrians.length} AdrianZERO tokens`, 'success');
                
            } catch (error) {
                console.error('Error loading AdrianZERO tokens:', error);
                showStatus('Error loading your AdrianZERO tokens: ' + error.message, 'error');
                adriansGrid.innerHTML = '<div class="error">Failed to load your AdrianZERO tokens</div>';
            }
        }

        function displayProfiles(profiles) {
            if (profiles.length === 0) {
                profilesGrid.innerHTML = '<div class="no-data">No active bounty profiles found</div>';
                return;
            }

            profilesGrid.innerHTML = profiles.map(profile => `
                <div class="profile-card">
                    <div class="profile-image">
                        <div class="image-loading">Generating preview...</div>
                        <img src="" alt="${profile.name}" style="display: none;">
                    </div>
                    <div class="profile-info">
                        <div class="profile-name">${profile.name}</div>
                        <div class="profile-reward">Reward: ${window.ethers.utils.formatEther(profile.reward)} $ADRIAN</div>
                        <div class="profile-stats">
                            <span>Recovered: ${profile.recovered}</span>
                            <span>Profile ID: ${profile.id}</span>
                        </div>
                        <div class="profile-traits">
                            <div class="traits-title">Required Traits:</div>
                            <div class="traits-list">
                                ${profile.traitIds.map(traitId => `<span class="trait-tag">${traitId}</span>`).join('')}
                            </div>
                        </div>
                        <button class="claim-btn" onclick="claimBounty(${profile.id})" disabled>
                            Select Adrian First
                        </button>
                    </div>
                </div>
            `).join('');

            // Generate images for each profile
            profiles.forEach((profile, index) => {
                setTimeout(() => {
                    generateProfileImage(profile, index, 'profilesGrid');
                }, 100 * index); // Small delay to ensure DOM is ready
            });
        }

        async function displayMyAdrians(adrians) {
            if (adrians.length === 0) {
                adriansGrid.innerHTML = '<div class="no-data">No AdrianZERO tokens found</div>';
                return;
            }

            // Generate HTML for all adrians first
            adriansGrid.innerHTML = adrians.map(adrian => `
                <div class="adrian-card" onclick="selectAdrian('${adrian.tokenId}')">
                    <div class="adrian-image">
                        <img src="${adrian.imageUrl}" alt="${adrian.title}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMzMzIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD48L3N2Zz4='">
                    </div>
                    <div class="adrian-info">
                        <div class="adrian-name">${adrian.title}</div>
                        <div class="adrian-id">Token ID: ${adrian.tokenId}</div>
                        <div class="adrian-status" id="adrian-status-${adrian.tokenId}">Loading status...</div>
                    </div>
                </div>
            `).join('');

            // Load status for each adrian
            for (const adrian of adrians) {
                try {
                    const status = await getTokenStatus(adrian.tokenId);
                    const approval = await checkAdrianLabCoreApproval(adrian.tokenId);
                    
                    if (status) {
                        const statusElement = document.getElementById(`adrian-status-${adrian.tokenId}`);
                        if (statusElement) {
                            let statusText = `Status: ${status.tokenStatus}`;
                            if (status.wasPurchased) {
                                statusText += ` (Purchased for ${window.ethers.utils.formatEther(status.purchasePrice)} ADRIAN)`;
                            }
                            
                            // Add approval status
                            if (approval.isApproved) {
                                statusText += ` | ✅ Approved`;
                            } else {
                                statusText += ` | ❌ Not Approved`;
                            }
                            
                            statusElement.textContent = statusText;
                            
                            // Add visual indicators
                            const card = statusElement.closest('.adrian-card');
                            if (card) {
                                let borderColor = '#333';
                                
                                switch (status.tokenStatus) {
                                    case 'ELIGIBLE':
                                        borderColor = approval.isApproved ? '#00ff00' : '#ffaa00';
                                        break;
                                    case 'CLAIMED':
                                        borderColor = '#ffff00';
                                        break;
                                    case 'DEPOSITED':
                                        borderColor = '#ff8800';
                                        break;
                                    case 'PURCHASED':
                                        borderColor = '#ff0088';
                                        break;
                                    default:
                                        borderColor = '#333';
                                }
                                
                                card.style.border = `2px solid ${borderColor}`;
                                
                                // Add approval indicator
                                if (approval.isApproved) {
                                    card.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.3)';
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Error loading status for token ${adrian.tokenId}:`, error);
                }
            }
        }

        function selectAdrian(tokenId) {
            // Remove previous selection
            document.querySelectorAll('.adrian-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Add selection to clicked card
            event.currentTarget.classList.add('selected');
            
            selectedAdrian = tokenId;
            
            // Update claim buttons
            document.querySelectorAll('.claim-btn').forEach(btn => {
                btn.textContent = 'Claim Bounty';
                btn.disabled = false;
            });
            
            showStatus(`Selected Adrian #${tokenId}`, 'success');
        }

        async function claimBounty(profileId) {
            if (!selectedAdrian) {
                showStatus('Please select an Adrian first', 'error');
                return;
            }

            try {
                showStatus('Preparing bounty claim transaction...', 'loading');
                
                // First, check and approve AdrianLabCore token
                const adrianApproved = await checkAndApproveAdrianLabCore(selectedAdrian);
                if (!adrianApproved) {
                    return; // User cancelled or error occurred
                }
                
                // For transactions, we need the wallet provider with signer
                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABI(), signer);
                
                showStatus('Executing bounty claim transaction...', 'loading');
                const tx = await contract.claimBounty(selectedAdrian, profileId);
                showStatus('Transaction sent! Waiting for confirmation...', 'loading');
                
                await tx.wait();
                showStatus('Bounty claimed successfully! Adrian has been deposited.', 'success');
                
                // Refresh data
                await loadData();
                
            } catch (error) {
                console.error('Error claiming bounty:', error);
                showStatus('Error claiming bounty: ' + error.message, 'error');
            }
        }

        async function generateProfileImage(profile, index, containerId = null) {
            try {
                console.log('Generating image for profile:', profile);
                console.log('Profile traitIds:', profile.traitIds);
                console.log('Profile traitIds type:', typeof profile.traitIds);
                console.log('Profile traitIds length:', profile.traitIds ? profile.traitIds.length : 'undefined');
                
                // Ensure traitIds is an array and convert strings to numbers if needed
                let traitIds = profile.traitIds;
                if (!Array.isArray(traitIds)) {
                    console.error('traitIds is not an array:', traitIds);
                    return;
                }
                
                // Convert BigNumber trait IDs to numbers (they come as BigNumber from ethers)
                const numericTraitIds = traitIds.map(traitId => {
                    let numeric;
                    if (traitId && typeof traitId.toNumber === 'function') {
                        // It's a BigNumber
                        numeric = traitId.toNumber();
                        console.log(`Converting BigNumber traitId ${traitId.toString()} to number: ${numeric}`);
                    } else {
                        // It's already a number or string
                        numeric = parseInt(traitId, 10);
                        console.log(`Converting traitId "${traitId}" to number: ${numeric}`);
                    }
                    return numeric;
                });
                
                console.log('Numeric trait IDs:', numericTraitIds);
                
                // Build query parameters from trait IDs
                const queryParams = numericTraitIds.map(traitId => `trait=${traitId}`);
                const queryString = queryParams.join('&');
                
                console.log('Query string:', queryString);
                
                // Use token ID 208 for the base image
                const imageUrl = `https://adrianlab.vercel.app/api/render/custom/208?${queryString}`;
                console.log('Generated image URL:', imageUrl);
                
                // Select the correct container
                let profileCards;
                if (containerId) {
                    const container = document.getElementById(containerId);
                    console.log(`Container ${containerId} found:`, container);
                    profileCards = container.querySelectorAll('.profile-card');
                    console.log(`Found ${profileCards.length} profile cards in ${containerId}`);
                } else {
                    profileCards = document.querySelectorAll('.profile-card');
                    console.log(`Found ${profileCards.length} profile cards globally`);
                }
                
                if (profileCards[index]) {
                    const img = profileCards[index].querySelector('img');
                    const loadingDiv = profileCards[index].querySelector('.image-loading');
                    
                    if (img && loadingDiv) {
                        // Set the image source directly without the problematic fetch test
                        img.src = imageUrl;
                        console.log('Image source set for index:', index);
                        
                        // Add error handling to the img element
                        img.onerror = () => {
                            console.log('Image failed to load for URL:', imageUrl);
                            loadingDiv.textContent = 'Image failed to load';
                            loadingDiv.style.background = 'rgba(255,0,0,0.1)';
                        };
                        
                        img.onload = () => {
                            console.log('Image loaded successfully for URL:', imageUrl);
                            // Hide loading div and show image
                            loadingDiv.style.display = 'none';
                            img.style.display = 'block';
                        };
                    } else {
                        console.log('No img or loading div found for index:', index);
                    }
                } else {
                    console.log('No profile card found for index:', index);
                }
                
            } catch (error) {
                console.error('Error generating profile image:', error);
            }
        }



        async function loadEthers() {
            return new Promise((resolve, reject) => {
                if (typeof window.ethers !== 'undefined') {
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js';
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load ethers'));
                document.head.appendChild(script);
            });
        }

        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';
            
            if (type !== 'loading') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
        }

        function getPatientZeroABI() {
            return [
                "function getActiveProfiles() external view returns (uint256[] memory)",
                "function getProfile(uint256 profileId) external view returns (string memory profileName, uint256[] memory traitIds, uint256 reward, bool active, uint256 recovered)",
                "function claimBounty(uint256 tokenId, uint256 profileId) external",
                "function isPatientZERO(uint256 tokenId, uint256 profileId) external view returns (bool)"
            ];
        }

        // Extiende el ABI para Recovery Center
        function getPatientZeroABIExtended() {
            return [
                ...getPatientZeroABI(),
                "function getDepositedTokens() view returns (uint256[] memory)",
                "function tokenToProfile(uint256) view returns (uint256)",
                "function getTokenPrice(uint256) view returns (uint256)",
                "function purchaseToken(uint256) payable",
                // ✅ NUEVOS - Historial de compras
                "function tokenWasPurchased(uint256) external view returns (bool)",
                "function tokenPurchasePrice(uint256) external view returns (uint256)",
                "function tokenPurchaser(uint256) external view returns (address)",
                "function tokenPurchaseProfileId(uint256) external view returns (uint256)",
                // ✅ NUEVA FUNCIÓN - Estado completo de token
                "function getTokenStatus(uint256 tokenId) external view returns (string memory tokenStatus, uint256 profileId, bool isDeposited, address depositor, bool canBeClaimed, uint256[] memory eligibleProfiles, bool wasPurchased, uint256 purchasePrice)"
            ];
        }

        // ABI para el token ERC20 ADRIAN
        function getAdrianTokenABI() {
            return [
                "function approve(address spender, uint256 amount) external returns (bool)",
                "function allowance(address owner, address spender) external view returns (uint256)",
                "function balanceOf(address account) external view returns (uint256)",
                "function decimals() external view returns (uint8)",
                "function symbol() external view returns (string memory)"
            ];
        }

        // ABI para AdrianLabCore (ERC721)
        function getAdrianLabCoreABI() {
            return [
                "function approve(address to, uint256 tokenId) external",
                "function setApprovalForAll(address operator, bool approved) external",
                "function getApproved(uint256 tokenId) external view returns (address)",
                "function isApprovedForAll(address owner, address operator) external view returns (bool)",
                "function ownerOf(uint256 tokenId) external view returns (address)"
            ];
        }

        async function loadRecoveryProfiles() {
            try {
                showStatus('Loading recovered profiles...', 'loading');
                if (typeof window.ethers === 'undefined') await loadEthers();
                // Use Alchemy RPC provider for read operations (same as TraitLab)
                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABIExtended(), provider);

                const depositedTokenIds = await contract.getDepositedTokens();
                if (!depositedTokenIds.length) {
                    document.getElementById('recoveryGrid').innerHTML = '<div class="no-data">No recovered profiles found</div>';
                    return;
                }

                const recoveryProfiles = [];
                for (const tokenId of depositedTokenIds) {
                    const profileId = await contract.tokenToProfile(tokenId);
                    const profile = await contract.getProfile(profileId);
                    const price = await contract.getTokenPrice(tokenId);
                    
                    console.log(`Recovery profile data for token ${tokenId}:`, {
                        profileId,
                        profile,
                        price: window.ethers.utils.formatEther(price)
                    });
                    
                    // Structure the profile exactly like Active Bounties
                    const structuredProfile = {
                        id: profileId,
                        name: profile[0], // profileName
                        traitIds: profile[1], // traitIds array
                        reward: profile[2], // reward
                        active: profile[3], // active
                        recovered: profile[4], // recovered
                        tokenId: tokenId,
                        price: price
                    };
                    
                    recoveryProfiles.push(structuredProfile);
                }

                // Render cards using the same structure as Active Bounties
                document.getElementById('recoveryGrid').innerHTML = recoveryProfiles.map((rp, index) => `
                    <div class="profile-card">
                        <div class="profile-image">
                            <div class="image-loading">Generating preview...</div>
                            <img src="" alt="${rp.name}" style="display: none;">
                        </div>
                        <div class="profile-info">
                            <div class="profile-name">${rp.name}</div>
                            <div class="profile-reward">Recovery Price: ${window.ethers.utils.formatEther(rp.price)} $ADRIAN</div>
                            <div class="profile-stats">
                                <span>Profile ID: ${rp.id}</span>
                                <span>Token ID: ${rp.tokenId}</span>
                            </div>
                            <div class="profile-traits">
                                <div class="traits-title">Required Traits:</div>
                                <div class="traits-list">
                                    ${rp.traitIds.map(traitId => `<span class="trait-tag">${traitId}</span>`).join('')}
                                </div>
                            </div>
                            <button onclick="recoverToken('${rp.tokenId}')" class="claim-btn">Recover Adrian</button>
                        </div>
                    </div>
                `).join('');
                
                // Generate images for recovery profiles using the same function as Active Bounties
                console.log('About to generate images for', recoveryProfiles.length, 'profiles');
                recoveryProfiles.forEach((rp, index) => {
                    console.log(`Generating image for profile ${index}:`, rp.name);
                    setTimeout(() => {
                        generateProfileImage(rp, index, 'recoveryGrid');
                    }, 100 * index); // Small delay to ensure DOM is ready
                });
            } catch (e) {
                document.getElementById('recoveryGrid').innerHTML = '<div class="error">Error loading recovered profiles</div>';
            }
        }

        // Check and approve ADRIAN tokens for PatientZERO contract
        async function checkAndApproveAdrianTokens(amount) {
            try {
                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const adrianToken = new window.ethers.Contract(ADRIAN_TOKEN_CONTRACT, getAdrianTokenABI(), signer);
                
                // Check current allowance
                const currentAllowance = await adrianToken.allowance(currentAccount, PATIENTZERO_CONTRACT);
                console.log('Current allowance:', window.ethers.utils.formatEther(currentAllowance));
                console.log('Required amount:', window.ethers.utils.formatEther(amount));
                
                if (currentAllowance.lt(amount)) {
                    showStatus('Approving ADRIAN tokens...', 'loading');
                    
                    // Approve the required amount
                    const approveTx = await adrianToken.approve(PATIENTZERO_CONTRACT, amount);
                    await approveTx.wait();
                    
                    showStatus('ADRIAN tokens approved successfully!', 'success');
                    return true;
                }
                
                return true; // Already approved
            } catch (error) {
                console.error('Error in approve:', error);
                showStatus('Error approving ADRIAN tokens: ' + error.message, 'error');
                return false;
            }
        }

        // Get complete token status
        async function getTokenStatus(tokenId) {
            try {
                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABIExtended(), provider);
                
                const status = await contract.getTokenStatus(tokenId);
                console.log(`Token ${tokenId} status:`, {
                    tokenStatus: status[0],
                    profileId: status[1].toString(),
                    isDeposited: status[2],
                    depositor: status[3],
                    canBeClaimed: status[4],
                    eligibleProfiles: status[5].map(p => p.toString()),
                    wasPurchased: status[6],
                    purchasePrice: window.ethers.utils.formatEther(status[7])
                });
                
                return {
                    tokenStatus: status[0],
                    profileId: status[1],
                    isDeposited: status[2],
                    depositor: status[3],
                    canBeClaimed: status[4],
                    eligibleProfiles: status[5],
                    wasPurchased: status[6],
                    purchasePrice: status[7]
                };
            } catch (error) {
                console.error('Error getting token status:', error);
                return null;
            }
        }

        // Check and approve AdrianLabCore token for PatientZERO contract
        async function checkAndApproveAdrianLabCore(tokenId) {
            try {
                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const adrianLabCore = new window.ethers.Contract(ADRIANZERO_CONTRACT, getAdrianLabCoreABI(), signer);
                
                // Check if user owns the token
                const owner = await adrianLabCore.ownerOf(tokenId);
                if (owner.toLowerCase() !== currentAccount.toLowerCase()) {
                    showStatus(`You don't own AdrianLabCore token #${tokenId}`, 'error');
                    return false;
                }
                
                // Check current approval
                const currentApproval = await adrianLabCore.getApproved(tokenId);
                const isApprovedForAll = await adrianLabCore.isApprovedForAll(currentAccount, PATIENTZERO_CONTRACT);
                
                console.log(`Token ${tokenId} approval status:`, {
                    currentApproval,
                    isApprovedForAll,
                    patientZeroContract: PATIENTZERO_CONTRACT
                });
                
                if (currentApproval.toLowerCase() === PATIENTZERO_CONTRACT.toLowerCase() || isApprovedForAll) {
                    console.log(`Token ${tokenId} is already approved for PatientZERO`);
                    return true;
                }
                
                // Directly approve the specific token
                showStatus(`Approving token #${tokenId} for PatientZERO...`, 'loading');
                const approveTx = await adrianLabCore.approve(PATIENTZERO_CONTRACT, tokenId);
                await approveTx.wait();
                showStatus(`Token #${tokenId} approved for PatientZERO!`, 'success');
                
                return true;
            } catch (error) {
                console.error('Error in AdrianLabCore approve:', error);
                showStatus('Error approving AdrianLabCore token: ' + error.message, 'error');
                return false;
            }
        }

        // Check AdrianLabCore approval status for a specific token
        async function checkAdrianLabCoreApproval(tokenId) {
            try {
                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const adrianLabCore = new window.ethers.Contract(ADRIANZERO_CONTRACT, getAdrianLabCoreABI(), provider);
                
                const currentApproval = await adrianLabCore.getApproved(tokenId);
                const isApprovedForAll = await adrianLabCore.isApprovedForAll(currentAccount, PATIENTZERO_CONTRACT);
                
                const isApproved = currentApproval.toLowerCase() === PATIENTZERO_CONTRACT.toLowerCase() || isApprovedForAll;
                
                console.log(`Token ${tokenId} approval check:`, {
                    currentApproval,
                    isApprovedForAll,
                    isApproved,
                    patientZeroContract: PATIENTZERO_CONTRACT
                });
                
                return {
                    isApproved,
                    currentApproval,
                    isApprovedForAll
                };
            } catch (error) {
                console.error('Error checking AdrianLabCore approval:', error);
                return { isApproved: false, currentApproval: null, isApprovedForAll: false };
            }
        }

        // Check if token was purchased
        async function checkTokenPurchaseHistory(tokenId) {
            try {
                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABIExtended(), provider);
                
                const wasPurchased = await contract.tokenWasPurchased(tokenId);
                const purchasePrice = await contract.tokenPurchasePrice(tokenId);
                const purchaser = await contract.tokenPurchaser(tokenId);
                const purchaseProfileId = await contract.tokenPurchaseProfileId(tokenId);
                
                console.log(`Token ${tokenId} purchase history:`, {
                    wasPurchased,
                    purchasePrice: window.ethers.utils.formatEther(purchasePrice),
                    purchaser,
                    purchaseProfileId: purchaseProfileId.toString()
                });
                
                return {
                    wasPurchased,
                    purchasePrice,
                    purchaser,
                    purchaseProfileId
                };
            } catch (error) {
                console.error('Error checking token purchase history:', error);
                return null;
            }
        }

        // Check ADRIAN token balance
        async function checkAdrianBalance(requiredAmount) {
            try {
                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const adrianToken = new window.ethers.Contract(ADRIAN_TOKEN_CONTRACT, getAdrianTokenABI(), provider);
                
                const balance = await adrianToken.balanceOf(currentAccount);
                console.log('ADRIAN balance:', window.ethers.utils.formatEther(balance));
                console.log('Required amount:', window.ethers.utils.formatEther(requiredAmount));
                
                if (balance.lt(requiredAmount)) {
                    showStatus(`Insufficient ADRIAN tokens. You have ${window.ethers.utils.formatEther(balance)} but need ${window.ethers.utils.formatEther(requiredAmount)}`, 'error');
                    return false;
                }
                
                return true;
            } catch (error) {
                console.error('Error checking balance:', error);
                showStatus('Error checking ADRIAN balance: ' + error.message, 'error');
                return false;
            }
        }

        async function recoverToken(tokenId) {
            try {
                showStatus('Processing recovery...', 'loading');
                if (typeof window.ethers === 'undefined') await loadEthers();
                
                // For transactions, we need the wallet provider with signer
                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABIExtended(), signer);
                
                // Get the price for this token
                const price = await contract.getTokenPrice(tokenId);
                console.log('Token price:', window.ethers.utils.formatEther(price));
                
                // Check if user has enough ADRIAN tokens
                const hasBalance = await checkAdrianBalance(price);
                if (!hasBalance) {
                    return;
                }
                
                // Check and approve ADRIAN tokens
                const approved = await checkAndApproveAdrianTokens(price);
                if (!approved) {
                    return;
                }
                
                // Execute the purchase
                showStatus('Executing recovery transaction...', 'loading');
                const tx = await contract.purchaseToken(tokenId);
                await tx.wait();
                
                showStatus('Adrian recovered successfully!', 'success');
                await loadRecoveryProfiles();
            } catch (e) {
                console.error('Error recovering token:', e);
                showStatus('Error recovering Adrian: ' + e.message, 'error');
            }
        }

        // Handle wallet changes
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('accountsChanged', function (accounts) {
                if (accounts.length === 0) {
                    disconnectWallet();
                } else {
                    currentAccount = accounts[0];
                    updateUI();
                    loadData();
                }
            });
        }

        // Load recovered tokens (PURCHASED status) - PROFILE-BASED VERSION
        async function loadRecoveredTokens() {
            try {
                showStatus('Loading recovered tokens...', 'loading');
                
                // Load ethers if not available
                if (typeof window.ethers === 'undefined') {
                    await loadEthers();
                }

                const provider = new window.ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL);
                const contract = new window.ethers.Contract(PATIENTZERO_CONTRACT, getPatientZeroABIExtended(), provider);
                
                const recoveredProfiles = [];
                
                // Iterate through profile IDs (like active bounties)
                // Start from profile ID 1 and go up until we find no more profiles
                let profileId = 1;
                let maxProfiles = 100; // Safety limit
                
                while (profileId <= maxProfiles) {
                    try {
                        const profile = await contract.getProfile(profileId);
                        console.log(`Profile ${profileId}: ${profile.profileName}, recovered: ${profile.recovered}, active: ${profile.active}`);
                        
                        // If this profile has recovered tokens, show it as recovered
                        if (profile.recovered > 0) {
                            // This profile has been successfully recovered - show it
                            recoveredProfiles.push({
                                id: profileId,
                                name: profile.profileName,
                                traitIds: profile.traitIds,
                                reward: profile.reward,
                                active: profile.active,
                                recovered: profile.recovered,
                                status: 'RECOVERED'
                            });
                        }
                        
                        profileId++;
                    } catch (error) {
                        // If getProfile fails, we've reached the end of profiles
                        console.log(`No more profiles found after ID ${profileId - 1}`);
                        break;
                    }
                }
                
                console.log(`Found ${recoveredProfiles.length} profiles with purchased tokens`);
                
                if (recoveredProfiles.length === 0) {
                    recoveredGrid.innerHTML = '<div class="no-data">No recovered profiles found</div>';
                    showStatus('No recovered profiles found', 'info');
                    return;
                }
                
                // Render using the same structure as Active Bounties
                recoveredGrid.innerHTML = recoveredProfiles.map((rp, index) => `
                    <div class="profile-card">
                        <div class="profile-image">
                            <div class="image-loading">Generating preview...</div>
                            <img src="" alt="${rp.name}" style="display: none;">
                        </div>
                        <div class="profile-info">
                            <div class="profile-name">${rp.name}</div>
                            <div class="profile-reward">Original Reward: ${window.ethers.utils.formatEther(rp.reward)} $ADRIAN</div>
                            <div class="profile-stats">
                                <span>Profile ID: ${rp.id}</span>
                                <span>Recovered: ${rp.recovered} token(s)</span>
                                <span>Status: ${rp.active ? 'ACTIVE' : 'INACTIVE'}</span>
                            </div>
                            <div class="profile-traits">
                                <div class="traits-title">Required Traits:</div>
                                <div class="traits-list">
                                    ${rp.traitIds.map(traitId => `<span class="trait-tag">${traitId}</span>`).join('')}
                                </div>
                            </div>
                            <div class="recovery-info">
                                <strong>Status:</strong> <span class="status-badge purchased">RECOVERED</span>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                // Generate images for recovered profiles using the same function as Active Bounties
                console.log('About to generate images for', recoveredProfiles.length, 'profiles');
                recoveredProfiles.forEach((rp, index) => {
                    console.log(`Generating image for profile ${index}:`, rp.name);
                    setTimeout(() => {
                        generateProfileImage(rp, index, 'recoveredGrid');
                    }, 100 * index); // Small delay to ensure DOM is ready
                });
                
                showStatus(`Found ${recoveredProfiles.length} recovered profiles`, 'success');
                
            } catch (error) {
                console.error('Error loading recovered tokens:', error);
                showStatus('Error loading recovered tokens: ' + error.message, 'error');
            }
        }



        // View token details (placeholder function)
        function viewTokenDetails(tokenId) {
            showStatus(`Viewing details for token ${tokenId}...`, 'info');
            // TODO: Implement detailed view or link to external viewer
        }

        // Load Bootstrap scripts
        const bootstrapScript = document.createElement('script');
        bootstrapScript.src = 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js';
        document.head.appendChild(bootstrapScript);
    </script>
</body>
</html> 